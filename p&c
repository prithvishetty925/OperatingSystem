#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<semaphore.h>
#define NUM_PHILOSOPHERS 5
#define NUM_CHOPSTICKS 5

void dine(int n);

pthread_t
philosopher[NUM_PHILOSOPHERS]:

pthread_mutex_t
chopstick[NUM_CHOPSTICKS]:

int main()
{
//Define counter var i and
status message
int i,status_message:
void*msg:

//Initialise the semaphore array
for(i=1;i<=NUM_CHOPSTICKS:i++)
{
status_message=pthread_mutex_init(&chopstick[i],NULL);
//Check if the mutex is initiated successfully
if(status_message==-1)
{
printf("\n Mutex initialisation failed"):
exit(1);
}
}
//Run the philosopher Thread using *dine()function
for(i=1;i<=NUM_PHILOSOPHERS:i++)
{
status_message=pthread_join(philosopher[i],&msg);
if(status_message!=0)
{
exit(1);
}
}


printf("\n Thread join failed \n");
//Destroy the chopstick Mutex array
for(i=0;i<=NUM_CHOPSTICKS;i++)
{
status_message=pthread_mutex_destroy(&chopstick[i]);
if(status_message!=0)
{
printf("\n Mutex Destroyed \n");
exit(1);
}
}
return 0;
}
void dine(int n)
{
printf("\n Philosopher %d is thinking",n);
//Philosopher picks up the left chopstick(wait)
pthread_mutex_lock(&chopstick[(n+1)%NUM_CHIOPSTICKS]);

//After picking up both the chopstick philosopher starts eating 
//Philosopher places down the left chopstic(signal)
pthread_mutex_unlock(&chopstick[n]);
pthread_mutex_unlock(&chopstick[(n+1)%NUM_CHOPSTICKS]);
printf("\n Philosopher %d Finished eating",n);
}
